#!/usr/bin/python3
# pylint: disable=invalid-name

"""
A JSON-based interface for depsolving using DNF.

By default it runs in daemon mode, meant to be run as a systemd service, and listens for requests on a socket.
In interactive mode, it reads a request through stdin, prints the result to stdout, and exits.
"""


import argparse
import hashlib
import json
import logging
import os
import pickle
import shutil
import socket
import socketserver
import sys
import tempfile

from datetime import datetime, timedelta
from http.server import BaseHTTPRequestHandler
from multiprocessing import Lock

import dnf
import hawkey


# Logging setup (to systemd if available)
log = logging.getLogger('dnf-json')
log.setLevel(logging.INFO)


class CacheState():
    """
    A CacheState keeps track of the cache folders.
    CacheState objects can update the list of used cache folders, which
    will associate a date object to the name of the folder.
    CacheState objects can ask to clean the unused cache folders.
    Meaning that the folders having reach a certain timeout will be deleted.
    """

    def __init__(self, cache_dir, cache_timeout, folder_dict=None):
        """
        cache_dir the place where the state is stored
        folder_dict a dict containing the existing list of cache folders
        cache_timeout a timedelta before a cache folder can be deleted
        """
        if folder_dict is None:
            folder_dict = {}
        self.cache_dir = cache_dir
        self.folder_dict = folder_dict
        self.cache_timeout = cache_timeout

    def update_used(self, folder):
        """
        Associate a datetime.now() to the folders given as parameters
        """
        log.debug("Folder %s was used", folder)
        self.folder_dict[folder] = datetime.now()

    def clean_unused(self):
        """
        Delete the folders having reach the timeout
        """
        log.info("clean unused folders")
        now = datetime.now()
        list_folder_to_delete = []
        for folder, then in self.folder_dict.items():
            delta = now - then
            log.debug("delete %s if %s > than %s", folder, delta, self.cache_timeout)
            if delta > self.cache_timeout:
                list_folder_to_delete.append(folder)
        for folder in list_folder_to_delete:
            del self.folder_dict[folder]
            shutil.rmtree(folder)

    @classmethod
    def load(cls, cache_dir):
        try:
            with open(os.path.join(cache_dir, "cache_state.pkl"), "rb") as inp:
                return pickle.load(inp)
        except FileNotFoundError:
            return cls(cache_dir, timedelta(hours=24))

    def store(self):
        with open(os.path.join(self.cache_dir, "cache_state.pkl"), "wb") as outp:
            return pickle.dump(self, outp)


class Solver():

    # pylint: disable=too-many-arguments
    def __init__(self, repos, module_platform_id, persistdir, cachedir, arch):
        self.base = dnf.Base()

        # Enable fastestmirror to ensure we choose the fastest mirrors for
        # downloading metadata (when depsolving) and downloading packages.
        self.base.conf.fastestmirror = True

        # We use the same cachedir for multiple architectures. Unfortunately,
        # this is something that doesn't work well in certain situations
        # with zchunk:
        # Imagine that we already have cache for arch1. Then, we use dnf-json
        # to depsolve for arch2. If ZChunk is enabled and available (that's
        # the case for Fedora), dnf will try to download only differences
        # between arch1 and arch2 metadata. But, as these are completely
        # different, dnf must basically redownload everything.
        # For downloding deltas, zchunk uses HTTP range requests. Unfortunately,
        # if the mirror doesn't support multi range requests, then zchunk will
        # download one small segment per a request. Because we need to update
        # the whole metadata (10s of MB), this can be extremely slow in some cases.
        # I think that we can come up with a better fix but let's just disable
        # zchunk for now. As we are already downloading a lot of data when
        # building images, I don't care if we download even more.
        self.base.conf.zchunk = False

        # Set the rest of the dnf configuration.
        self.base.conf.module_platform_id = module_platform_id
        self.base.conf.config_file_path = "/dev/null"
        self.base.conf.persistdir = persistdir
        self.base.conf.cachedir = cachedir
        self.base.conf.substitutions['arch'] = arch
        self.base.conf.substitutions['basearch'] = dnf.rpm.basearch(arch)

        for repo in repos:
            self.base.repos.add(self._dnfrepo(repo, self.base.conf))
        self.base.fill_sack(load_system_repo=False)

    @staticmethod
    def _dnfrepo(desc, parent_conf=None):
        """Makes a dnf.repo.Repo out of a JSON repository description"""

        repo = dnf.repo.Repo(desc["id"], parent_conf)

        if "name" in desc:
            repo.name = desc["name"]
        if "baseurl" in desc:
            repo.baseurl = desc["baseurl"]
        elif "metalink" in desc:
            repo.metalink = desc["metalink"]
        elif "mirrorlist" in desc:
            repo.mirrorlist = desc["mirrorlist"]
        else:
            assert False

        if desc.get("ignoressl", False):
            repo.sslverify = False
        if "sslcacert" in desc:
            repo.sslcacert = desc["sslcacert"]
        if "sslclientkey" in desc:
            repo.sslclientkey = desc["sslclientkey"]
        if "sslclientcert" in desc:
            repo.sslclientcert = desc["sslclientcert"]

        # In dnf, the default metadata expiration time is 48 hours. However,
        # some repositories never expire the metadata, and others expire it much
        # sooner than that. We therefore allow this to be configured. If nothing
        # is provided we error on the side of checking if we should invalidate
        # the cache. If cache invalidation is not necessary, the overhead of
        # checking is in the hundreds of milliseconds. In order to avoid this
        # overhead accumulating for API calls that consist of several dnf calls,
        # we set the expiration to a short time period, rather than 0.
        repo.metadata_expire = desc.get("metadata_expire", "20s")

        return repo

    def _repo_checksums(self):
        checksums = {}
        for repo in self.base.repos.iter_enabled():
            # Uses the same algorithm as libdnf to find cache dir:
            #   https://github.com/rpm-software-management/libdnf/blob/master/libdnf/repo/Repo.cpp#L1288
            if repo.metalink:
                url = repo.metalink
            elif repo.mirrorlist:
                url = repo.mirrorlist
            elif repo.baseurl:
                url = repo.baseurl[0]
            else:
                assert False

            digest = hashlib.sha256(url.encode()).hexdigest()[:16]

            repomd_file = f"{repo.id}-{digest}/repodata/repomd.xml"
            with open(f"{self.base.conf.cachedir}/{repomd_file}", "rb") as f:
                repomd = f.read()

            checksums[repo.id] = "sha256:" + hashlib.sha256(repomd).hexdigest()

        return checksums

    @staticmethod
    def _timestamp_to_rfc3339(timestamp):
        return datetime.utcfromtimestamp(timestamp).strftime('%Y-%m-%dT%H:%M:%SZ')

    def dump(self):
        packages = []
        for package in self.base.sack.query().available():
            packages.append({
                "name": package.name,
                "summary": package.summary,
                "description": package.description,
                "url": package.url,
                "repo_id": package.repoid,
                "epoch": package.epoch,
                "version": package.version,
                "release": package.release,
                "arch": package.arch,
                "buildtime": self._timestamp_to_rfc3339(package.buildtime),
                "license": package.license
            })
        return {
            "checksums": self._repo_checksums(),
            "packages": packages
        }

    def depsolve(self, package_spec, exclude_spec):
        self.base.install_specs(package_spec, exclude_spec)
        self.base.resolve()
        dependencies = []
        for tsi in self.base.transaction:
            # Avoid using the install_set() helper, as it does not guarantee
            # a stable order
            if tsi.action not in dnf.transaction.FORWARD_ACTIONS:
                continue
            package = tsi.pkg

            dependencies.append({
                "name": package.name,
                "epoch": package.epoch,
                "version": package.version,
                "release": package.release,
                "arch": package.arch,
                "repo_id": package.repoid,
                "path": package.relativepath,
                "remote_location": package.remote_location(),
                "checksum": (
                    f"{hawkey.chksum_name(package.chksum[0])}:"
                    f"{package.chksum[1].hex()}"
                )
            })
        return {
            "checksums": self._repo_checksums(),
            "dependencies": dependencies
        }


class DnfJsonRequestHandler(BaseHTTPRequestHandler):
    """
    Answers Http requests to depsolve or dump packages.
    """

    # Synchronisation necessary for the multiprocess request handling.
    # Class property shared across all instances
    _process_lock = Lock()

    def __init__(self, *args, **kwargs):
        self.cache_dir = None
        super().__init__(*args, **kwargs)

    def init_cache_folder_list(self, repos):
        cache_folders = []
        for repo in repos:
            if "baseurl" in repo:
                url = repo["baseurl"]
            elif "metalink" in repo:
                url = repo["metalink"]
            elif "mirrorlist" in repo:
                url = repo["mirrorlist"]
            else:
                assert False
            digest = hashlib.sha256(url.encode()).hexdigest()[:16]
            repoid = repo["id"]
            cache_folders.append(f"{self.cache_dir}/{repoid}-{digest}")
        return cache_folders

    def _send(self):
        self.client_address = ('', 0)

    def respond(self, code, response):
        self._send()
        self.send_response(code)
        self.send_header("Content-Type", "application/json")
        self.end_headers()
        self.wfile.write(json.dumps(response).encode("utf-8"))

    def do_POST(self):
        """
        do_Post answer the request of a depsolving/dump.
        Depsolving and dump require synchronizing caches on disk to perform their
        operations. Caches folders are created for each remote repository. Since
        the user request contains the list of repository the space taken can grow
        indefinitely.

        This solution implements a cache cleaning mechanism. It works by deleting
        the directories on a timeout based rule and by keeping the last used date
        in a synced file on disks.

        This method is multiprocess safe.
        """
        with self._process_lock:
            request = {}
            cache_state = None
            try:
                content_len = int(self.headers.get('Content-Length'))
                request_raw = self.rfile.read(content_len)
                request = json.loads(request_raw.decode("utf-8"))
                err = validate_request(request)
                if err is not None:
                    self.respond(400, err)  # bad request
                self.cache_dir, err = setup_cachedir(request)
                if err is not None:
                    self.respond(500, err)
                cache_state = CacheState.load(self.cache_dir)
                result, err = solve(request, self.cache_dir)
                if err is not None:
                    self.respond(500, err)
                else:
                    self.respond(200, result)
            finally:
                if cache_state is not None:
                    for cache_folder in self.init_cache_folder_list(request.get("repos", [])):
                        cache_state.update_used(cache_folder)
                    cache_state.clean_unused()
                    cache_state.store()


# The dnf-json web server has to use forks to serve the requests. Because the
# dnf library is leaking memory in its Cpp side.
class SystemDActivationSocketServer(socketserver.ForkingMixIn, socketserver.UnixStreamServer):

    def __init__(self):
        super().__init__('', DnfJsonRequestHandler)

    def server_bind(self):
        LISTEN_FDS = int(os.environ.get("LISTEN_FDS", 0))
        # set from entrypoint if differs from 3
        LISTEN_FD = int(os.environ.get("LISTEN_FD", 3))
        log.debug("service bind")
        log.debug("rebind socket")
        log.debug("address_family: %d ", self.address_family)
        log.debug("socket_type: %d ", self.socket_type)
        if LISTEN_FDS > 1:
            log.warning("More than one LISTEN_FDS")
        self.socket = socket.fromfd(LISTEN_FD, self.address_family, self.socket_type)


def setup_cachedir(request):
    arguments = request["arguments"]
    arch = arguments["arch"]
    # If dnf-json is run as a service, we don't want users to be able to set the cache
    cache_dir = os.environ.get("OVERWRITE_CACHE_DIR", "")
    if cache_dir:
        cache_dir = os.path.join(cache_dir, arch)
    else:
        cache_dir = arguments.get("cachedir", "")

    if not cache_dir:
        return "", {"kind": "Error", "reason": "No cache dir set"}

    return cache_dir, None


def solve(request, cache_dir):
    command = request["command"]
    arguments = request["arguments"]
    repos = arguments["repos"]
    arch = arguments["arch"]
    module_platform_id = arguments["module_platform_id"]

    with tempfile.TemporaryDirectory() as persistdir:
        try:
            solver = Solver(
                repos,
                module_platform_id,
                persistdir,
                cache_dir,
                arch
            )
            if command == "dump":
                result = solver.dump()
                log.info("dump success")
            elif command == "depsolve":
                result = solver.depsolve(
                    arguments["package-specs"],
                    arguments.get("exclude-specs", [])
                )
                log.info("depsolve success")
            return result, None

        except dnf.exceptions.MarkingErrors as e:
            log.info("error install_specs")
            return None, {
                "kind": "MarkingErrors",
                "reason": f"Error occurred when marking packages for installation: {e}"
            }
        except dnf.exceptions.DepsolveError as e:
            log.info("error depsolve")
            return None, {
                "kind": "DepsolveError",
                "reason": f"There was a problem depsolving {arguments['package-specs']}: {e}"
            }
        except dnf.exceptions.Error as e:
            log.info("error repository setup")
            return None, {
                "kind": type(e).__name__,
                "reason":    f"Error occurred when setting up repo: {e}"
            }


def daemon():
    formatter = logging.Formatter(
        fmt="%(asctime)s %(name)s.%(levelname)s: %(message)s",
        datefmt="%Y.%m.%d %H:%M:%S"
    )
    handler = logging.StreamHandler(stream=sys.stdout)
    handler.setFormatter(formatter)
    log.addHandler(handler)
    log.info("Starting the dnf-json server")
    # start the web server
    server = SystemDActivationSocketServer()
    server.serve_forever()


def fail(err):
    log.error("%s: %s", err["kind"], err["reason"])
    sys.exit(1)


def respond(result):
    print(json.dumps(result))


def validate_request(request):
    command = request.get("command")
    if command not in ("depsolve", "dump"):
        return {
            "kind": "InvalidRequest",
            "reason": "invalid command '{command}': must be either 'depsolve' or 'dump'"
        }

    arguments = request.get("arguments")
    if not arguments:
        return {
            "kind": "InvalidRequest",
            "reason": "empty 'arguments'"
        }

    repos = arguments.get("repos")
    if not repos:
        return {
            "kind": "InvalidRequest",
            "reason": "no 'repos' specified"
        }

    arch = arguments.get("arch")
    if not arch:
        return {
            "kind": "InvalidRequest",
            "reason": "no 'arch' specified"
        }

    module_platform_id = arguments.get("module_platform_id")
    if not module_platform_id:
        return {
            "kind": "InvalidRequest",
            "reason": "no 'module_platform_id' specified"
        }
    return None


def interactive():
    handler = logging.StreamHandler(stream=sys.stderr)
    log.addHandler(handler)

    request = json.load(sys.stdin)
    err = validate_request(request)
    if err is not None:
        fail(err)

    cachedir, err = setup_cachedir(request)
    if err is not None:
        fail(err)
    result, err = solve(request, cachedir)
    if err is not None:
        fail(err)
    else:
        respond(result)


def main():
    parser = argparse.ArgumentParser(description=__doc__)
    parser.add_argument("--mode", "-m", dest="mode", type=str, default="daemon",
                        help="run mode: 'daemon' or 'interactive'")
    args = parser.parse_args()
    mode = args.mode

    if mode == "daemon":
        daemon()
    elif mode == "interactive":
        interactive()
    else:
        print(f"invalid mode: {mode}")
        sys.exit(1)


if __name__ == "__main__":
    main()
